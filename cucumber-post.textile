uperFood Effect: Acceptance tests with cucuber, vested interests, and sloppy thought

I recently heard an account of a web development project both from the point of view of the consultancy and the client. The designer told me how his company didn't compromise on what they know to be right. In their latest gig they educated a client about how to do development work the Right Way. "Breaking the client's assumptions about how things are done might annoy them at first, but we will not do bad work. Good work leads to a solid reputation and lasting business success". The founder of the web consultancy boasted that not only have the project went well, but the client and him were now "good friends".

A few days later I bumped into the client and inquired about their recent development work. 

"An absolute nightmare. They wouldn't listen to what I wanted, and wasted my time with things I didn't care about. Mind, they did great technical work, but they had absolutely no business sense. I mean all we wanted was a website [Technically, it was a web app, but most peple don't distinguish between the two.]"

It's obvious that the consultancy screwed up; they pushed the manager to use agile methodologies when it wasn't appropriate. He was given read feature files to approve, yet he didn't give a damn. Step out of your programmer skin for a momement and pretend you are a busy manager while you read this:

Feature: In order to let customers organise their information
         As an adminitrator of a microsite
         I want to be able to add subpages

Scenario: Adding a subpage
  Given I am logged in
  Given a microsite with a home page
  When I press "Add subpage"
  And I fill in "Title" with "Gallery"
  And I press "Ok"
  Then I should see a document called "Gallery"

Scenario, not feature description taken from: http://elabs.se/blog/15-you-re-cuking-it-wrong

This is purportedly stake-holder language. I disagree. I've outsource two projects prior to becoming a technie, and I've also worked on a variety of projects for other stakeholders. The following is the stake-holder language I would have used:

  I can add subpages with custom titles to my microsite.

If it takes you ten lines to communicate this idea, then you've wasted my time. Granted, BDD experts like Elizabthe Keogh would point out that even Jonas of Elabs was Cuking it wrong even in the above example, taken from his post "You're Cucking It Wrong".  She tell us:

"If your scenario starts with “When the user enters ‘Smurf’ into ‘Search’ text box…” then that’s far too low-level. However, even “When the user adds ‘Smurf’ to his basket, then goes to the checkout, then pays for the goods” is also too low-level. You’re looking for something like, “When the user buys a Smurf.”"
From http://sirenian.livejournal.com/71439.html

Taking Elizabeth's point seriously leads us to a rather naseating conclusion: Anyone using the built-in web steps in rails-cucumber is had been doing it wrong. These web steps are too low-level and should never be condoned. But you cannot blame programmers for doing so. By providing these low level step definition in the box, Cucumber is strongly encouraging developers to do things wrong.

Lets consider another angle on the development project gone wrong. I'm the client again and I receive the Cuke above. The first thing that comes to my mind is "why in earth's name are you "pausing to consider the business value of a feature"? I, the client, have already determined the business value; in accepting a quote from you I've determined that the business benefit is worth its price. You second guessing using "in order to" steps is ficticious at best. Your job is to implement; business value isn't your realm. Indeed, this is mild form of churning; in case you forgot I didn't hire you to play make-belief analyst. Unless you are specifically employed to help the client decide on features, and are sitting down wth a client to figure out what features their business needs, Cucumber isn't inappropriate.

I'd contend something further. In a lot of projects I've seen Cucumber used in it isn't appropriate. The vast majority. Having Cuked muy guts out for almost a year before finding some sense, I have an inkling of why this state of affairs exists. You see, we succumbed to the Superfood effect. 

h2. The Superfood Effect

Every time I open the health section of a national newspaper I'm told that they've found a new breed of Acai berry which cures Asthma, Firbomylagis, heart disease and even unwanted pregnancy. My sex drive will soar and my emotions will level. How is all this possible you ask? Because these delicious tasting, albeit expensive, superfoods contain powerful antioxidants and flavonoids.

Cucumber is a nutrient dense testing framework which solves the problem of communicating with clients, by letting us write business readable tests in plain text, all whilst making it fun. I check the website for health warning; apparently there are none. Cucumber is a panacea for all your testing woes.

What you probably didn't know is that the FDA made an injuncton stopping these companies using such unproven and unscientific claims in their marketing: http://www.fda.gov/NewsEvents/Newsroom/PressAnnouncements/2008/ucm116861.htm

But you know better right? You've read the Cucumber homeage, seen the Peepcode and the Railscast (three times), you know that "Declarative testing" over imperative testing is the key to Cuking it Right, and have seen another forty or so slide decks on SlideShare repeating the same points without ever adding a modicum of critical thought.

h2. The Advantages of Cucumber

 test automation is software development, 
that it involves significant maintenance costs, and that they can and must make deliberate, 
vigilant effort to keep maintenance costs lo
http://dhemery.com/pdf/writing_maintainable_automated_acceptance_tests.pdf

The alleged advantages of Cucumber is well trodden territory so I'll just give a summary of the most commonly cited arguments in Cucumber's favour:

# Cucumber is in plain language so non-technical stake holders can read them and maybe even write them.
# Cucumber forces you to slow down and think about the value a feature brings before delving into implementation.
# Cucumber is high level documentation.
# Cucumber, with its high level descriptors and understandable web steps, makes testing less scary for developers beginning automated testing.
# Cucumber is language agnostic and therefore is ideal is hyper-polyglot projects.

[references]

h2. The Disadvantages of Cucumber

There has not been enough thought on the downsides of using Cucumber and so I'm going to get into some detail here. I'm comparing Cucumber to old fashioned integration tests, or request specs if your prefer RSPEC.

h3. 1. Cucumber breaks text editors

Text editors, like VIM, multiple productivity. Auto-completion ease the use of long, descriptive method names as we no longer need to type them in full or remember their signature precisely. Compilation checks prior to saving catch many syntax errors before they cause harm. Our text editors reduce errors we introduce through typo, forgetfulness, or sloppiness.

Cucumber's steps are method names in Gherkin syntax. Some argue that these steps aren't code, for example when a declarative style is used which omits the use of any paramters. This is rreleavant here because, whatever you want to call the step definitions, they still break our text editors because they contain white space, include their parameters at non-standard locations (When “john@gmail.com” has “4” unsent messages), and use regular expressions for pattern dispatch ("and|or"). Our editors are not adapted to deal with this syntax and so autocomplete, search and other features break down, slowing productivity.

h3. 2. Cucumber requires maintainenance of parallel worlds

I'm assuming that anyone thinking of using Cucumber already tests their models using something like Test::Unit or Rspec. Both of these libraries require you to set up a separate environment, their own worlds if you will.  We organise and manage increasingly complicated test suites by placing shared test code into helper methods shared across tests and categorising our tests using tagging systems. We use tools like Spork to speed up our tests, or watchr to run them automatically. We add Gems to gain access to helper methods which aid in testing key areas, perhaps freezing time, reading emails, or faking web requests. 

Cucumber doesn't like to share. It does not automatically use many of our exsting test configurations and helper methods. Our taxonomy of tags carry no weight we must mirror the system without cucumber. We set up Cucumber separately, often duplicating code, and always increasing complexity and thus scope for error. These parallel worlds must be maintained by the project owner, and creators of testing gems must now cater for two masters. Cucumber takes another toll.

h3. 3. Cucumber's routing causes you cognitive strain 

Cognitive strain is the otal weight of facts and rules we must hold in our minds to be productive using a technology. Rails strains; When I began using Rails four years ago I faced an extended period of difficulty as I acclimatized to the labyrinthine naming patterns of routes, rules about what does and does not get pluralized, and subtle distinctions between various ActiveRecord::Base persistence methods. Strain is sometimes necessary to enable us to operate powerful tools, but all things equal, less strain for equal power is a good thing.

When testing Rails application using Cucumber the mention of a certain web page, for example "the login page", requires us to map this natural language descript to a more technical description. Here's a reminder:

[test that it won't pick up someting like this]
    when /the login page/  
       login_path

Cucumber adds an abstraction layer over Rails routes, an area which already congitively strains. This led to pain and error on larger projects. As I added new features I presumed I would unintentionally describe some routes with numberous natural language descriptions. Perhaps I'd call "the login page" the "the sign in page" one day, and "the log in page" another. When I did this, Cucumber complained that it could not find the permuted path and so I had to look inside the paths.rb file to remind myself of my previous phrasing, then return to the step definition and fill in the correct English language mapping of the route helper mapping to the actual url. That's a lot of mental mapping, and a lot of room for error.

I've experimented with removing the paths.rb file are automagically determining the route, but this ends up either turning the language of your Cuke into unacceptable steps such as "And then I am on the new user session page" or, if you want to preserve the non-techncial communicative dimension of Cucumber, then you'll need unacceptably complex logic. By defintion, paths.rb is a necessary part of Cuking It Right.

h3. 4. Cucumber's organisation defaults are impractical 

My favorite feature of Rails, is one of its simplest: everything has its right place. Mailers go in one folder, models go in another and configurations go somewhere else else. Presuming that a project sticks to convention, you can find the source code for any function effortlessly. This brings enormous productivity advantages.

If you Cuke correctly (Jonas link), you've write your steps in declarative style step definitions, written using the language of the stake-holder, word that he can understand. This means, amongst other things, that you don't use hash tables of model attributes in your scenarios, or css selectors or any other technical details,

[check convention]
Upon running these files Cucumber will ask you to create step definitions. Cucumber’s convention is to keep these steps in a file with the pattern FEATURE_NAME_steps.rb. The step definitions are trivial to find; that is until you begin reusing your step definitions so as to get your testing code DRY. Say you write a feature which promotes a post on the homepage . You will place your step definition for “Given I promote a post” in promote_posts_feature_steps. Twenty six weeks later you are writing another feature connected to promoting posts, and you'd like to reuse the step. I’ve found two things tend to happen in this scenario: 

In the happier scenario I remember the original method exists, look up it’s name and reuse it. Ideally I abstract it to a global helper, rather than leave it in the promote_posts_feature_steps.rb, since its position there suggests exclusive connection with that feature, when this is no longer true. The difficulty here is that now you need to thematically separate shared step definitions into files. This is harder than it sounds; as the conceptual barriers in integration tests are blurred. If I were to use Cucumber again, I’d like to try one big file. Not pretty, but solvable. Now for the unhappy route.

I might have forgotten that I previously wrote a step definition for promoting a post (or not seen that another programmer had done so), and so I repeat the knowledge of do so in the taxon_steps.rb, My code is no longer DRY and if I forget to refactor one version I will cause confusing test failures. Cucumber’s default way of organising features sets you up for these difficulties.

h3. 5. Increased Wordiness

Brevity is the sole of wit. If you are using Ruby, Clojure, CoffeeScript, or Haskell you surely know this. Yet, you use Cucumber to write method names with two or three times as many characters as theire plainer Capybara equivalents. Compare:

Given I am on the home page #27 characters
visit root_path #15 characters

Increased wordiness reduces expressiveness and power, and introduces error on the basis that there more characters typed is more places a typo can seep in. Yes this is necessary for non techncial communication, but remember we're talking about the disadvantages here.

h4. 6. Cucumber syntactically discourages simple code reuse.

Cucumber users tend to write their step definition in terms of other step definitions.  The library creators have implicitly encouraged this by creating ever simpler means for doing so, culminating in the current steps function:

When /^I toggle the full sample on the “(^”.*)” product/ do |product_name|
  steps %Q{
    When I am on the last upload page for “#{product_name}”
    And I follow "full_samples"
    And I press "toggle_full_sample"
    When I refresh the page
  }
end

This is an abomination. Why? For one you get all the disadvantages of Cucumber with none of its advantages. You have increased wordiness and thus higher error rates, your editor breaks, your method names are difficult, or impossible to remember, and your tests run more slowly. Worst of all, unless you are disciplined in refactoring, your original step definitions for the nested step will remain, say in the uploads_steps.rb file. This is problematic because it’s use outside of uploads.feature is not expected, and so the definition may get deleted when someone on the project scraps the uploads feature. To avoid this the reused step definition should be moved to clearly marked global helper step files immediately after resue. But even if you are disciplined and careful enough to do this, you still suffer the penalties of Cucumber’s syntax despite there being no non technical stake holder who will ever read this code. 

This anti-pattern is rampant in the Rails community. Even Jonas, an otherwise sensible Cucumber user, promotes reuse step definition in "You're Cukin It Wrong". I can understand where he's coming from. He wants to remain DRY but doesn't want the hassle of encapsulate the step definitions in Ruby methods. But when you are in the programmer territory wouldn't it be advantageous ake full advantage of the brevity, precision, composability, regularity and editor support of a full programming language? Your imagaine is the limit:

When /^I toggle the full sample on the “(^”.*)” product/ do |product_name|
   admin do 
        feature_latest_upload 
        refresh_page
        should_see(sample_path, “features”)
    end
end

The set of features in Cucumber facilitating reuse of steps, alongside the emphasis on Cucumber’s web steps over Capbyara, to the point where the seeming majority of programmers only know of the Cucumber version, is a technical tragedy.

The lack of abstaction tools, I belive, is the main reason why companies attempted test automation only to abandon the effort within a few months when tey become too difficult to maintain. If you've ever had the tests get our of sync on a big project you'll know what I mean.


h2. When Should I Be Using Cucumber

We've seen that Cucumber has advantages; we've also seen that Cucumber has its disadvantages. Whether Cucumber use makes sense is context-dependent,depending on particular on whether your situation gives Cucumber the advantages that justifiy its weight.


Cases Where Cucumber Use Is Absurb:

h4. You are writing your Cucumber step definitions in a manner that isn't obvious to your mother

h4. You are a sole developer on your own project.

As there are no "non technical stakeholders" the chief advantage of using Cucumber is gone. Since you can read code, Capybara method names are faster to comprehend and serve as equivalent documentation of what the applicaiton does.

visit about_us_path
click_link “buy”

h4. You are woring on open source software

Same reasons as above.

h4. You are working in an early stage startup

Is your business-minded partner really going to pore over your feature files instead of hustling clients. I hope not. Its a small startup, small enouh for you two to communicate in person or email about features.

h4. Your client did not request and does not read your feature files.

I think this is extraordinarily common. I've never ever head of a client who prefers to open up a list of scattered feature files scattered in nested folders and read them. The client is already using Pivotal Tracker to track features, or at least excel. This has the advantage of being all on one page and being exponentially more concise Don\t be that consultancy.

h4. You are not in charge of determing the business value of someting

Cases Where Cucumber May be Sensible:

I don't know.

# I=

# You are working on a major enterprise project with technical stakeholders, e.g. implementing an online banking system for a major bank. I've heard accpetance tests being put to good use in such situations, but I have no expereince.

Requirements For Justification



|What are you doing? |Should I Be Cuking It?| Why? |
|You are writing step definitions using Web steps in an imperative style|
[check multi language use]
|Using 3 more languages extensively. | Maybe. | Tests the full stack of languages as step definitions can be in multiple languages|
|You are working alone| God no | You are technical and Capybara.|
|You have a project with a budget under $20k | No 
|You are working on an open source project | No | Everyone is technical. |
|You ar working in an early startup| No | You are the tech department / easier to communicate with your co-founder|

This logic suggests five rules about sensible usage:


The problem is we aren't following these sensible rules.

Research:

h2. What clients want

In my experience, your average small client cares about only one acceptance test criteria. I'm going to write this in Gherkin for you:

feature: As a manager of some sort 
         In order to get on with my job
         I want the goddamn thing to work

scenario:It does what its supposed to
         [Given omitted.  Normal people don't think about state. They think about cause and effect.]
         When someone uses it
         Then it* works

I put an asterisk beside "it" to signal reference to the totality of features you'd previously agreed to - whether that was explicitly through a spec document, exchanged emails, and conversations, or implicitly, in the sense of reasonable expectations, such as 'all websites I've ever seen do that so mine ought to too'. Telling a user that they got their email/password combon is en example of this.

In my experience as a consumer and producer of development services, these features are documented somewhere outside the code, either in an Excel sheet or on something like Pivotal Tracker, typically stored on a convenient single page.


Opinions here may differ, but I vote a firm no.

Cucumber may be capable of plain language, but its never used this way in practice. In my work as both a producer, collaborator and purchaser of Rails development work, I have never, even once, seen Cucumber steps written in the style Jonas promotes. Since this is only anecdotal I researched six of the most popular open source Rails apps, [Spree, Refinery, Redmine, Tracks, Radian and Diaspora] of them them four employed Cucumber and all broke Jonas’s rule: “A step description should never contain regexen, CSS or XPath selectors, any kind of code or data structure. [Tracks was the best of the lot]. It should be easily understood just by reading the description.". Smells like hypocrisy to me. Either use Cucumber as its intended or bite the bullet and join me with Capybara.

#typical cucumber step

 scenario: sends an invitation
      given a user with email "bob@bob.bob"
      when i sign in as "bob@bob.bob"
      and i follow "by email"
      and i fill in "user_email" with "alex@example.com"
      and i press "send an invitation"
      then i should have 1 devise email delivery
#stake holder language[quit the waffling. we’re busy]

i should be able to send invitations to my friends.

Many teams use Cucumber when there is no need for carrying the overhead of plain language communication. A solopreneur effort, or a tech startup will either have a fully technical team or close enough communication that it has no business wasting development time with Cucumber.  They say that 19/20 startups fail? Welcome to the 19.

 A consultancy where the client doesn’t read Cucumber steps is another example of wasted Cucumber. My experience makes me suspect that most clients couldn’t care less about your Cucumbers. They care about one feature: it “works  (as intended)”. As a consumer of consultancy services I never cared for reading Cucumber features (part of it was that they were written using web_steps.rb, making it unreadable and dull).  Collaborate with Pivotal Tracker, or excel. Let them tick off features as they are done. You can turn use Conextra stories within these programs if you like, and of course you will have integration tests to prevent regression each story. Sure Cucumber lets you put these Conextra stories into the code, but why repeat yourself? On the client’s tab no less.

The over supposed advantage is that cucumber lets you think about the business value of the feature before implementing it. Wait. We’ve already established that you couldn’t possibly we a tech startup. Either you are working in enterprise or working for a client, in which both cases I presume you have a boss who makes the business decisions and you implement. Soldiers don’t decide who to they fight; they fight. Let’s stop the make believe.

I get that lacking documentation is a major issue in large systems. Linus recently said that the biggest issues with linux were never technical; they were lack of documentation (and hardware manufacturers). I retort that 1) On technical teams Capybara steps are slightly easier to read,owing to precise definition and concision. 2) On non technical teams Capybara methods names, as produced say by Rspec or acking for test, is good enough documentation, and any record in specs or pivotal tracker form good extras.

In short Cucumber is often unnecessary as either the stake holders are all technical, communication is redundant due to other systems, and in the rare cases that it can be used as a communication tool, it is practically never used in a way that could offer any of the advantages to non technical stake holders.

H3. The solution

The best way to avoid the problems is not to use it. Use Test::Unit integrations tests or Rspec request specs instead. Your editor supports it, there is no parallel world to maintain nor is there an added routing abstraction to get your mind around. Since it’s just Ruby, it’s designed for code reuse. For the technical documentation is formed from the test method names by Rspec or TestUnit, and if tests as documentation is important to you then it’s hardly brainfuck:

Visit about_us_path
Click_link “buy”

Organisation of helper methods can be messy, using one big file makes sense as well. The Skinny on Cucumber: You Ain’t Going To Need It. Really. Ultimately, and perhaps most importantly is this quote from Peter Cooper on Hacker News:

“ If a particular type of testing is slowing you down or causing you to be less productive, don't do it! But stick with the tests and processes that do allow you to be quick but without abandoning testing in favor of the old "code and pray" approach.

Some people recommend Steak; don’t fall for this - it’s an unnecessary library and a technical dead end. Its author seem to be on the same track as I am but ended up sitting on the fence by trying to be both an acceptance tests and have Ruby syntax.Why not take a side, save yourself a dependency and just write old fashioned integration tests. 

Ask yourself, honestly, if the reason you've been enjoying using Cucumber is because you enjoy integration testing and working with Capybara? The answer, I suspect, is yes. See you on the bright side of the ghetto.

Addendum:

If you must use Cucumber I’ve distiled these practices:

* Share global test helper modules with Rspec to minimize code duplication
* Delete web steps.rb as soon as you install Cucumber. Learn Capybara’s API instead
* Write short, high level declarative steps. Remember your intent is in the feature files, your implementation is in step definitions. 
* Never call a step definition within another step definition. If you want to be dry, encapsulate the contents of both step definitions in a Ruby helper method and call it from both. If it makes sense to add this to you app, e.g. a model’s API, then do so.
* Use one big bag of helper methods - in Ruby not web-steps.


